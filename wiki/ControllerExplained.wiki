#summary learn all about ActiveWeb controllers

<wiki:toc max_depth="3" />


=Introduction=


Controllers are at the heart of an !ActiveWeb application. These are classes wich designed to process an HTTP request. They are somewhat similar to Java Servlets, but even more similar to Ruby on Rails, Grails anall sind SpringMVC controllers. A simplest controller looks like this:
{{{
public class GreetingController extends AppController{
   public void index(){}
}
}}}

A controller above is a working controller, even though it does not have any code in it. Such a controller is automatically mapped to a URL"
{{{
http://host:port/context/greeting
}}}

=Controller actions=

A controller action is a method that is designed to process an HTTP request. For example, in the example above, the URL will be mapped to the "action" index by default. However, if the URL looked like this:
{{{
http://host:port/context/greeting/hello
}}}
then it would map to action "hello":
{{{
public class GreetingController extends AppController{
   public void hello(){}
}
}}}


=Controllers and HTTP methods=

The HTTP specification defines methods: GET, POST, DELETE, PUT, CONNECT and HEAD. Currently ActiveWeb supports  GET, POST, DELETE, PUT, as the most used methods. 

An HTTP request is not only mapped to an action, but also its HTTP method must correspond to an action's HTTP method. Action HTTP methods are configured with annotations, {{{@GET, @POST, @PUT, and @DELETE}}}. 
----
<font color="navy">
However, if annotation is missing, an action is mapped to HTTP GET method by default
</font>
----

This makes it unnecessary to use annotations except cases when you need so-called "destructive" action. A destructive action is the one that is designed to change a state of a resource (in REST style of web programming). 

Here is an example of a destructive action is:
{{{
public class BooksController extends AppController{

   @PUT
   public void updateBook(){}
}
}}}

!ActiveWeb promotes REST-style web programming and will not allow to access an action that is configured for one HTTP method with another. For instance, I you try to access the `GreetingController#index` with HTTP method POST, you would get an exception:
{{{
activeweb.ControllerException: Cannot access action 
app.controllers.GreetingController.index with HTTP method: 'POST' because it is 
configured for method: 'GET'
}}}

=RESTful controllers=

A restful controller is almost the same as a regular controller. The difference is that in a standard controller you can define any number of actions and configure them with annotations to accept any HTTP methods. RESTful controllers by contrast have a fixed set of actions and these actions will accept certain HTTP methods. In order to create a RESTful controller, you need to do two things:

  # Add `@RESTful` annotation to the controller class 
  # Provide a fixed set of action methods in the body of controller

Here is an example of a RESTful controller taken from Kitchensink application:

{{{
@RESTful
public class RpostsController extends AppController {

    public void index(){...}

    public void newForm(){...}

    public void create(){...}

    public void show(){...}

    public void destroy(){...}
}}}
A RESTful controller is allowed to have 7 methods, and they all are automatically mapped to the following URSs and HTTP methods:
{{{
==========================================================================================
verb    path                   action          used for
==========================================================================================
GET     /books                 index 	       display a list of all books
GET     /books/new_form        new_form        return an HTML form for creating a new book
POST    /books                 create 	       create a new book
GET     /books/id              show            display a specific book
GET     /books/id/edit_form    edit_form       return an HTML form for editing a books
PUT     /books/id              update          update a specific book
DELETE 	/books/id              destroy         delete a specific book
}}}

There is no need to add any other annotations to RESTful controllers.

If you examine the table above, you will see that a combination of a path and HTTP method is mapped to an action. For instance, a path '/books' is mapped twice, with GET HTTP method to action `index`, an with POST to action `create`. This makes for elegant, REST-style URLs and leads ultimately to better user experience. 

=Location of controllers in project=

The page [StructureOfActiveWebProject Structure of a web project] states that controllers are located in a package:
{{{
app.controllers
}}}

!ActiveWeb specifies that all controllers are located in this package or sub-packages. 

=Controller paths=
A controller path is made of a sub-package and a controller name. A controller name is _not_ a class name, but rather underscored, flattened name part of a class simple name. 

Example 1
{{{
package app.controllers;
class BooksController{..} // ===> controller path: /books
}}}


Example 2:
{{{
package app.controllers;
class UniversityBooksController{..} // ===> controller path: /university_books
}}}

Example 3
{{{
package app.controllers.depaul;
class UniversityBooksController{..} // ===> controller path: /depaul/university_books
}}}


Example 4
{{{
package app.controllers.depaul.chicago;
class UniversityBooksController{..} // ===> controller path: /depaul/chicago/university_books
}}}



=V in MVC=

!ActiveWeb does not use JSPs. Period. Instead it uses [http://freemarker.sourceforge.net/ FreeMarker] (FM). The FM templates are located in this directory:
{{{
src/main/webapp/WEB-INF/views
}}}


=Mapping to views=

The directory: `src/main/webapp/WEB-INF/views` has subdirectories. These subdirectories are named after controller paths. This makes it easy to find FM templates (views)  associated with controllers. 

==Default mapping to views==

Under normal circumstances, the HTTP request is applied to an action, and then the framework passes control to a view. Under these conditions, there is no need for any configuration or code. 

Example: if a HTTP GET request is sent to this URL: `http://hostname/context/greeting`, then the framework will invoke a GreetingControoller, and by default action `index`:
{{{
public class GreetingController extends AppController{
   public void index(){}
}
}}}

After execution of action, the !ActiveWeb will find a template: 
{{{
src/main/webapp/WEB-INF/views/greeting/index.ftl
}}}
will render it, and send results to the browser. 

!ActiveWeb in the same spirit as ActiveJDBC does not have any configuration files. Most actions are based on conventions. 

==Override mapping to relative views==

In some cases, you need to override default mapping to views. You will use a `render()` method for this: 
{{{
public class GreetingController extends AppController{
   public void index(){
      //some code here
      render("show");
   }
}
}}}

The `render("show");` will signal to !ActiveWeb  that instead of "index", you want to render "show".
Since you did not provide any other information, !ActiveWeb will assume that this view will be found at the same location:
{{{
src/main/webapp/WEB-INF/views/greeting/show.ftl
}}}

==Override mapping to absolute views==

Sometimes you need to call a view that "belongs" to a different controller, or even some shared view. In that case, you can specify an "absolute" path to a view like this:
{{{
public class GreetingController extends AppController{
   public void index(){
      //some code here
      render("/shared/show");
   }
}
}}}
!ActiveWeb will use the following view to render:
{{{
src/main/webapp/WEB-INF/views/shared/show.ftl
}}}

=Passing data to views=

Passing data to views is done with two methods:
  * assign(name, value)
  * view(name, value)

There is no difference between these methods, they are aliases. 

Example:

{{{
public class GreetingController extends AppController{
   public void index(){
       view("name", "John Doe");
   }
}
}}}

The corresponding view can look like this:
{{{
Hello, my name is: ${name}
}}}

You could have guessed that the output will look like:
{{{
"Hello, my name is: John Doe"
}}}

=Getting request parameters=
Getting request parameters is the most important part of any web application. !ActiveWeb provides a few methods to achieve this goal:

==getting a single parameter==

{{{
public class GreetingController extends AppController{
   public void index(){
       String name = param("name");
   }
}
}}}

==getting all parameters==

{{{
public class GreetingController extends AppController{
   public void index(){
      Map<String, String[]> allParams = params();
   }
}
}}}


==getting all values for a single parameter==

This is in cases for submit parameters with multiple values, such as selects:

{{{
public class GreetingController extends AppController{
   public void index(){
      List<String> states = params("states");
   }
}
}}}


==getting a first value from each submitted parameter==

This is in cases for submit parameters with multiple values, such as selects:

{{{
public class GreetingController extends AppController{
   public void index(){
      Map<String, String> firstValues = params1st()
   }
}
}}}
The return value is a map where keys are names of all parameters, while values are first value for each parameter, even if such parameter has more than one value submitted.

=Ajax APIs=

==detecting if a request is Ajax==

Controllers (and filters alike) provide a simple way to detect if a request is a from an XmlHttpRequest in browser:
{{{
public class GreetingController extends AppController{
   public void index(){
      if(xhr()){
         ...
      }else{
         ...
      }
   }
}
}}}
The `xhr();` method also has an alias: `isXhr();`.

==Responding to Ajax call==

!ActiveWeb provides a simple but powerful method `respond(..)`:

{{{
public class GreetingController extends AppController{
   public void index(){
      respond("<message>hello</message>").contentType("text/xml").status(200);
   }
}
}}}

It is easy to use this method to send plain text, XML, JSON, or any other text format as a response to Ajax call.

----
<font color="navy">Method `respond(..)` is good for building REST services, where a client is not a browser and responce format is not HTML.
</font>
----



Sections to be added to this page:

    * download of files
    * streaming of data to client
    * upload of files
    * session management
    * cookies
    * built in logging
    * logging of request parameters 
    * Thread safe