#summary ActiveWeb promotes TDD/BDD with convenient APIs

<wiki:toc max_depth="2" />

= TDD/BDD with !ActiveWeb =

!ActiveWeb shines when it comes to testing. Specifically, it promotes TDD/BDD approach to testing of wen applications. At the heart, it uses [http://www.junit.org/ JUnit] as a testing framework, but it provides a number of test classes to be sub-classed for  various purposes. !ActiveWeb allows to do a full test of any web functionality during a regular build. !ActiveWeb provides a number of classes for testing.

!ActiveWeb classes that make it easy to test all have a suffix "Spec". This is a nod to RSpec, but also a good practice - think of these not as tests that assert values, as is usually done in Java projects, but as specs, or specifications of behavior. The more you think of them as specifications/blueprints, the more you will think of writing them before writing actual implementations. 


----
*This page is not an exhaustive list of test APIs, just a directional guide and a how-to.*
----

=JSpec =

While !ActiveWeb tests are written with the popular JUnit testing framework, traditionally expectations are written with [http://code.google.com/p/activejdbc/wiki/JSpec JSpec].

* [http://code.google.com/p/activejdbc/wiki/JSpec Please, follow this link to learn more about JSpec]. *



=DBSpec for database tests=

`activeweb.DBSpec`  is a super class for tests that require a database connection. It is integrated with !ActiveWeb configuration and will automatically open and close a database connection before and after a test respectively. 
It is customary for !ActiveWeb projects to use a database for testing that is different than the one that is used for running the project live even on a developers workstation. This makers it easy to preserve data in place in the "development" database, and still use the full power of database CRUD access to your test database. 

For example, you could have some user data in a development database which will allow you to log in, and perform other operations, and yet you can run test logic against your test database, destroy and re-create any data in it, without having to destroy your development database.

While DBSpec is usually used to test models, it can be used to test any code that require a database connection. If you need to get a hold of that connection, you can use class Base from ActiveJDBC:
{{{
java.sql.Connection connection = Base.connection();
}}}

===Configuration===
Database configuration is described on DatabaseConfiguration page. DBSpec class will look for connections configured with a method `testing()`. Example taken from DatabaseConfiguration page:

{{{
 1. public class DbConfig extends AbstractDBConfig {
 2.  public void init(AppContext context) {
 3.      environment("development").jndi("jdbc/kitchensink_development");
 4.      environment("development").testing().jdbc("com.mysql.jdbc.Driver", "jdbc:mysql://localhost/kitchensink_development", "root", "****");
 5.      environment("hudson").testing().jdbc("com.mysql.jdbc.Driver", "jdbc:mysql://172.30.64.31/kitchensink_hudson", "root", "****");
 6.      environment("production").jndi("jdbc/kitchensink_production");
 7.  }
 8.}
}}}

Specifically, line 4 configures a test connection to be used during the test.
In case you work with multiple databases, you can configure more than one test connection. DBSpec will open all connections marked for tests.

==Transaction management==

DBSpec will  start a transaction before the test and roll it back after the test, ensuring integrity of data in a test database, and also that different tests would not affect one another by modifying data in the database. 

== Example of a DBSpec test ==

Lets say we are developing a blog, and we need to persist a post. A post will have title, content and author. All these attributes are required. A test will look like this then:

{{{
public class PostSpec extends DBSpec {
    @Test
    public void shouldValidateRequiredAttributes(){
        Post post = new Post();
        a(post).shouldNotBe("valid");
        a(post.errors().get("author")).shouldBeEqual("Author must be provided");
        post.set("title", "fake title", "author", "fake author", "content", "fake content");
        a(post).shouldBe("valid");
        post.save();
        a(Post.count()).shouldBeEqual(1);
    }
}
}}}


technically speaking you can use it for any test requiring a connection, but it also easy to use for Model tests. Model tests are tests for ActiveJDBC models. In case you use Hibernate or another persistence framework, you will have to setup connections in a different way.


Here is an example of a model we are testing:
{{{
public class Post extends Model {
    static {
        validatePresenceOf("title", "content");
        validatePresenceOf("author").message("Author must be provided");
    }
}
}}} 


= !ControllerSpec - test your controllers=

`activeweb.ControllerSpec` is a super class for controller tests. This class is used by unit tests that test a single controller. Controllers are tested by simulating a web request to a controller (no physical network is involved, and no container initialized).

----
*All APIs available to controllers in !ControllerSpec are also available to all other controller and integration specs* 
----


==Naming convention==
Subclasses must follow a simple naming convention: subclass name must be made of two words: controller short class name and word "Spec". Example, if there is a controller:
{{{
package app.controllers;

 public class GreeterController extends AppController{
   ...
 }
}}}

then the test will look like this:
 {{{
package app.controllers;

 public class GreeterControllerSpec extends ControllerSpec{
 ...
 }
}}}

----
Note that the package is the same for test as it is for controller, since !ActiveWeb will use reflection to determine the controller to be tested
----

==Simulating different HTTP requests==
{{{
1. public class HelloControllerSpec extends ControllerSpec
2.   @Test
3.   public void shouldSendGetToIndex(){
4.      request().get("index");
5.   }
6. }
}}}

In a snippet above on line 4, the method `request()` allows to simulate a call to a controller !HomeController. This line reads like this:

Send GET request to `HomeController`, action `index`. There are other methods for sending different HTTP methods:

  * post(action)
  * put(action)
  * delete(action)

==Simulating parameters with HTTP requests==
{{{
1. public class HelloControllerSpec extends ControllerSpec
2.   @Test
3.   public void shouldSendParamsToIndex(){
4.      request().param("first_name", "John").param("last_name", "Deere").get("index");
5.      a(assigns().get("message")).shouldBeEqual("Hello, John Deere, welcome back!");
6.   }
7. }
}}}

This test is a little more complex, we are sending two parameters with the request, and also checking the value controller assigned to a view.  

The above example can be simplified to use a` params()` form that takes an even number of names an values for parameters:

{{{
1. public class HelloControllerSpec extends ControllerSpec
2.   @Test
3.   public void shouldSendParamsToIndex(){
4.      request().params("first_name", "John", "last_name", "Deere").get("index");
5.      a(assigns().get("message")).shouldBeEqual("Hello, John Deere, welcome back!");
6.   }
7. }
}}}

This makes it a bit easier to read. 


== Integrating views==
How many times you wished developing a web application in Java to be able to generate a full HTML from the application in test, as if the application was running?
Well, with !ActiveWeb you can finally do this by using the `integrateViews()` method.

Here is a modification on the previous example, but with the `integrateViews()`

{{{
1. public class HelloControllerSpec extends ControllerSpec
2.   @Test
3.   public void shouldSendParamsToIndexAndGenerateHTML(){
4.     request().params("first_name", "John", "last_name", "Deere").integrateViews().get("index");
5.     a(assigns().get("message")).shouldBeEqual("Hello, John Deere, welcome back!");
6.     a(responseContent().contains("<span class='greeting'>Hello, John Deere, welcome back!</span>")).shouldBeTrue();
7.   }
8. }
}}}

Line 4 causes the framework to execute the controller, and pass all data from it to the view and the generate HTML as in a normal application flow. 

Method `responseContent()` simply returns entire HTML generated by the view. At which point, you can use variety of technologies in Java to test its structure (easier if you stick to XHTML in your templates), as well as content.

We simply test on line 6 that there exists a span with specific content merged by template from data passed in from controller.

==Mocking and testing==
Mocking and testing of services is related to the concept of Dependency Injection and is described in [DependencyInjection#Mocking_and_testing] section.


==Posting binary content==

Sometimes you need to test a case when binary data is POSTed to a web application. This can be easily tested with the content() method:
{{{
 public class HelloControllerSpec extends ControllerSpec
   @Test
   public void shouldSendBytes(){
     byte[] mybytes = ...
     request().content(mybytes).post("index");
     a(responseContent().contains("<message>success</message>")).shouldBeTrue();
   }
 }
}}}

==Uploading files==

Simulating file upload can be done with the formItem() method:

{{{
 public class HelloControllerSpec extends ControllerSpec
   @Test
   public void shouldUploadImageFile(){
     byte[] imagebytes = ...
     request().formItem("file.png", "image", true,  "applicaiton/png", imagebytes).contentType("'multipart/form-data'").post("upload");
     a(responseContent().contains("<message>success</message>")).shouldBeTrue();
   }
 }
}}}

----
Most methods chained after method `request()` are chained because they all return a special instance of `RequestBuilder`. This allows to call the same method more than once, including formItem() to simulate uploading of multiple files. 
----


==Working with sessions==

There is a `session()` method available in controller specs. This method allows to put objects into session before a test and then also allows to verify values if it is expected that a controller should place something into a session during execution.

{{{
 public class LoginControllerSpec extends ControllerSpec
   @Test
   public void shouldLoginByIdAndPassword(){
     request().params("id", "mmonroe", "password", "kennedy").post("index");
     a(session().get("user")).shouldNotBeNull();
   }
 }
}}}

Conversely, if you want to test another controller, you could "login" inside a @Before metod by placing a User object into a session.


==Working with cookies==
Cookies can be sent with a response using a `cookie()` method:

{{{
1.  public class HelloControllerSpec extends ControllerSpec
2.   @Test
3.   public void shouldCookie(){
4.   request().cookie(new Cookie("app_id", "12345")).get("index");
5.   a(cookie("last_access")).shouldNotBeNull();
6.   }
7. }
}}}

In this spec, we are sending one cookie with the request on line 4., but also are checking that "HelloController" sent another cookie to the client. 


==Great for TDD==

!ActiveWeb controller specs allow for true TDD, since they do not have a compiler dependency on controllers. You can describe full behavior of your controller before a controller class even exists. Simplest example:
{{{
public GreeterControllerSpec extends ControllerSpec{
  @Test
  public void shouldRespondWithGreetingMessage(){
      request().get("index");
      a(responseCode()).shouldBeEqual(200);
      a(assigns().get("message")).shouldBeEqual("Hello, earthlings!");
  }
}
}}}

In a code snippet above, a request with HTTP GET method is simulated to the GreeterController, index() action.

Controller is expected to assign an object called "message" with value "Hello, earthlings!" to a view. 

It is easy to describe a controller behavior in a !ControllerSpec, making it trivial and pleasurable to practice real TDD.



=DBControllerSpec - test controllers with DB connection=

`activeweb.DBCOntrollerSpec` class serves as a super class for controller tests requiring database connections. In effect, this class combines the logic of !ControllerSpec and DBSpec. When it comes to naming convention of a controller to be tested, the functionality is identical that of !ControllerSpec, but at the same time it will open a connection to DB before test and close after (will also roll back transaction) 

= !IntegrationSpec - test multiple controllers together =

While ControllerSpec and DBControllerSpec allow to test a single controller, the class IntegrationSpec allows to write entire scenarios for testing multiple controllers.

Example:
{{{
1. public class SimpleSpec extends IntegrationSpec {
2.     @Test public void shouldNavigateToTwoControllers(){
3.         controller("home").get("index");        
4.         a(statusCode()).shouldBeEqual(200);        
5.         controller("greeter").param("name", "Bob").integrateViews().get("index");        
6.         a(responseContent().contains("Our special greeting is extended to Bob")).shouldBeTrue();        
7.     }
8. }
}}}


Lets decompose code snippet:

  * Line 3: a controller !HomeController is executed with HTTP GET  request which is dispatched to its action index()
  * Line 4: we verify that the response code of execution was 200
  * Line 5: controller !GreeterController's index() action is executed with HTTP GET and parameter name=Bob. Additionally, we call method `integrateViews()` which will require the framework to execute the corresponding view after controller, which will provide us with that view's output - usually HTML, but can be XML, Json, whatever  that view is producing.
  * Line 6; we examine the content of the produced view output. 

Note that we can run this code even in the absence of both controllers, but of course it will fail. Now, we can actually write controller classes to satisfy the tests, lets write a !GreetingController (as being the most "complicated" of the two):

{{{
public void GreeterController extends AppController{
  public void index(){
     view("name", param("name"));
  }
}
}}}

The corresponding view might look like:
<code language="html">
<span>Our special greeting is extended to ${name}</span>
</code>
and will be located in file:
{{{
/views/greeter/index.ftl
}}}


=DBIntegrationSpec - combines !IntegrationSpec and DBSpec =

`activeweb.DBIntegrationSpec` class serves as a super class for controller tests requiring database connections. In effect, this class combines the logic of IntegrationSpec and DBSpec. It will allow to write scenarios to test multiple controllers, but at the same time it will open a connection to DB before test and close after (will also roll back transaction), as DBSpec would. 

= !AppIntegrationSpec - bootstraps !ControllerFilters into test=

`activeweb.AppIntegrationSpec` is a class that will bootstrap entire application, complete with ControllerFilters. The only difference of running your application under AppIntegrationSpec and running it live, is that the DBConnectionFilter is disabled, and instead database connection is provided exactly the same way as in DBSpec, DBControllerSpec or DBIntegrationSpec.

In other words, think of AppIntegrationSpec as the same with DBIntegrationSpec, but all filters will trigger as in a real application. 


----
*None of the !IntegrationSpecs require  the same naming convention as !ControllerSpec or DBCOntrollerSpec.*
----

= Testing Views=
It is possible to test just a view template with !ActiveWeb. There is a special class for that called !ViewSpec. Here is an example of a template to be tested (template file name `/person/show.ftl`):

{{{
Name: ${name}
}}}

The view test might look something like this:

{{{
public void shouldRenderShow(){
   a(render("/person/show", "name", "John").shouldEqual("John");
}
}}}

There is also a way to test for `<@content for` output, inject mock or real services into custom tags, etc. In other words, one can write very stringent tests for views independent of the rest of the application. just as if views were first grade application components.


=Conclusion=
This collection of super classes allows to write very thorough set of tests covering application functionality