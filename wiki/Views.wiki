#summary all about views for ActiveWeb developer

<wiki:toc max_depth="2" />

= Introduction =

Views in !ActiveWeb are also called templates. They are located in the following directory:
{{{
 ..src/main/webapp/WEB-INF/views
}}}

=No JSPs=

!ActiveWeb does not use JSPs. The main reason for not using JSPs is inability to test generated HTML with JSPs in a unit test. While the first implementation of !ActiveWeb used JSPs as the rendering engine, as soon as we started implementing the [Testing] framework, we quickly realized that this is simply impossible with JSPs. Generating HTML from a JUnit test is complex and impractical and would also be time consuming. Besides, the number of problems with different versions of JSP and JSTL specifications would be a nightmare to maintain. Thus we made a hard choice early on in 2010 to not use JSPs all together. In the long run this has proven to be a good decision, since it is possible to write very thorough tests with !ActiveWeb.

=!ActiveWeb uses !FreeMarker=
!ActiveWeb uses !FreeMarker as a templating engine. Please see [FAQ#Why_FreeMarker_? Why FreeMarker?] for more information. 

!ActiveWeb has a pluggable architecture that allows to integrate any other engine, such as Velocity, as long as they can implement [http://code.google.com/p/activeweb/source/browse/trunk/activeweb/src/main/java/activeweb/TemplateManager.java TempalteManager] interface. 

=!FreeMarker configuration=


TODO: complete this




=Templates=
!ActiveWeb templates are in fact !FreeMarker templates. However, there are a number of !ActiveWeb conventions for template naming and placement. Templates are located in sub-directories of this top view directory:
{{{ 
src/main/webapp/WEB-INF/views
}}}

The sub-directories are usually named after controllers. Controller name would loose suffix "Controller", and the remainder would be transformed from !CamelCase to underscore, for example, `HomeController` templates are located in sub-directory 
{{{
src/main/webapp/WEB-INF/views/home
}}}
and `OuterSpaceController` templates are located in:
{{{
src/main/webapp/WEB-INF/views/outer_space
}}}

Controller package is not considered in search of templates. Usually templates belong to a controller, but there can also be template that are shared. In that case, you can create any arbitrary directory under template top directory and place your shared templates there:
{{{
src/main/webapp/WEB-INF/views/shared
}}}


=Partials=

Partials are snippets of HTML pages, hence the word. Usually they host chunks of code repeating in a few places. In much the same way that a regular programming language allows develpers to refactor and keep repeating patterns of code in one place, partials a used to keep HTML code that is repeated. It is not to say though that you cannot put any arbitrary HTML code, you can.

The main power of partials is in their ability to iterate HTML snippets over data collections, as well as ability to "widgetize" HTML snippets.

Partials are somewhat similar to JSP includes, but they have some special characteristics that JSPs do not.

==Partials naming and location==
Partials are !FreeMarker templates as any other, but the name of file must start with underscore:

{{{
src/main/webapp/WEB-INF/views/greeting/_hello.ftl
}}}

Location of partials is the same as for regular templates, that is they are located in sub-directories of the top view directory.

==Include partials with Render tag==
Partials are included into a host page with a Render tag. Lets say there is a template called `index.ftl` located in directory `market` and partial `_fruit.ftl` located in the same diretory:
{{{
src/main/webapp/WEB-INF/views/market/index.ftl
src/main/webapp/WEB-INF/views/market/_fruit.ftl
}}}

then you can render `_fruit.ftl` inside `index.ftl` like this:
{{{
<html>
...
<@render partial="fruit"/>
...
</html>
}}}

As you can see, when you are referring to a partial, you *specify name without underscore*.
----
The Render tag requires at least one attribute present: "partial" which refers to a local or shared partial by name.
----

==Rendering shared partials==
In a previous example, you can see that a partial was co-located with the host template. Sometimes you need to render a partial in a number of templates. To accomplish this, you can place a partial into a new view directory and refer to a partial with "absolute" path, such as:
{{{
<html>
...
<@render partial="/shared/fruit"/>
...
</html>
}}}
This assumes that you have a partial fruit at this location:
{{{
src/main/webapp/WEB-INF/views/shared/_fruit.ftl
}}}
Use this technique to incude a common widget in a few pages. 

==Iterating with partials==
It is quite common to iterate over collections in a web application. Sometimes  you need to build a `<table>`, a list `<ul>` or repeating pattern of HTML code. Usually developers resort to loops inside templates, and although !FreeMarker provides this functionality, using partials provides a cleaner solution, as partials can iterate automatically.

Lets say we have a partial called `_fruit.ftl`:
{{{
Fruit name: ${fruit}<hr>
}}}
If we have a collection in context (java.util.List, for instance) with these values: ["apple", "prune", "pear"], and named fruits, then we can render this partial as a collection from host page like this:

{{{
<@render partial="fruit" collection=fruits/>
}}}
Rendering will result in this output:
{{{
Fruit name: apple<hr>Fruit name: prune<hr>Fruit name: pear<hr>
}}}
As you can see, iteration is easier with partials compared to loops. The partial will take care ot iterating automatically.

==Implicit counter in partial==
Partials interating over a collection have a built-in implicit variable maintaining an index of a collection. The name of this variable is made up of a name of a partial and word "counter". This means that for the above example, the name will be "fruit_counter". You can use this value inside a partial like any other context value. The above example with the counter modification:
{{{
Fruit name: ${fruit}, index: ${fruit_conter}<hr>
}}}
will yield:
{{{
Fruit name: apple, index: 0<hr>Fruit name: prune, index: 1<hr>Fruit name: pear, index: 2<hr>
}}}

==Partials with collections and spacers==
Notice in above examples  that the horizontal line `<hr>` is rendered at the bottom of each iteration of a partial. This is because it is really a part of a partial. It is quite common that you need to space the iterating snippets of HTML with some sort of a spacer made up of arbitrary HTML. Partials provide this capability with the use of a "spacer" partial. Lets say we use this partial as a spacer (located in `src/main/webapp/WEB-INF/views/shared/_divider.ftl`):
{{{
<div class='spacer'/>

}}} 
if we then render our fruits with this spacer such that"
{{{
<@render partial="fruit" collection=fruits spacer="divider"/>
}}}
we will get the following output:
{{{
Fruit name: apple<hr><div class="spacer"/>
Fruit name: prune<hr><div class="spacer"/>
Fruit name: pear<hr>
}}}
As you can see, the content of the spacer was inserted between the contents of the iterating partial, and the good thing is that it was not appended after the last iteration.
The reason for a new line is because we have it in a "divider" partial.


==Passing arguments to partials==
You can pass an argument value to a partial in much the same way as you can to a method. 

Lets say we have a host template:
{{{
<@render partial="fruit_name" a_fruit=fruit_name/>
}}}
and a partial (`_fruit_name.ftl`) with content:
{{{
Fruit name is: ${a_fruit}
}}} 
Then the output of a partial will be:
{{{
Fruit name is: apple
}}}
considering that there is a varialbe `fruit_name` in context. This variable could be passed in by controller, or created inside the template. The types of values passed in like this are not limited to strings.


==Boundary indicators for collection partials==
If you have a partial that iterates over a collection and you need to render special content conditionally if this is a first or last time in the iteration, you can use special variables set by the framework called `first` and `last`:

{{{
<#if first>
I'm the first in line!
</#>
<#if last>
I'm the last in line!
</#>

more content...
}}}



LinkTo tag and unobtrusive !JavaScript



=link_to tag and unobtrusibe !JavaScript=

!ActiveWeb provides a<@link_to/>. This tag generates an HTML anchor tag and is capable of regular HTML links, as well as Ajax capability.
 
==Attributes for configuration==
 *  *controller*: path to controller, such as: `/admin/permissions` where "admin" is a sub-package and "permissions" is a name of a controller. In this example, the controller class name would be: `app.controllers.admin.PermissionsController`. If a controller path is specified, the preceding slash is mandatory. Optionally this could be a name of a controller from a default package: "permissions", and in this case, the controller class name is expected to be `app.controllers.PermissionsController`. If a name of controller is specified, the preceding slash can be omitted. This attribute is optional. If this attribute is omitted, the tag will use the controller which was used to generate the current page. This makes it convenient to write links on pages for the same controller.
 *  *action*: name of an action. Optional. If this attribute is omitted, the action will default to "index".
 *  *id*: id, as in a route: /controller/action/id. Optional.
 *  *html_id*: value of this attribute will be used to set the HTML ID of the Anchor element. Optional.
 *  *query_string*: query string as is usually used in GET HTTP calls - the part of a URL after the question mark. Optional. Either query_string or query_params allowed, but not both.
 *  *query_params*: java.util.Map with key/value pairs to be converted to query string. Optional. Either query_string or query_params allowed, but not both.
 *  *destination*: id of an element on page whose content will be set with a result of an Ajax call. Optional.
 *  *form*: id of a form element on the page, whose content will be serialized into the Ajax call. This content will be submitted to the server controller/action as input. Optional.
 *  *method*: HTTP method to use. Acceptable values: GET (default), POST, PUT, DELETE. Optional.
 *  *before*: Name of a !JavaScript function to call before making Ajax call. Optional. This function does not receive any arguments.
 *  *before_arg*: Value for the JS function argument provided in "before" attribute. This could be an ID of an element, string, or any other arbitrary parameter. Any object will be converted to string. Optional.
 *  *after*: Name of a !JavaScript function to call after making Ajax call. This function receives the value of a "after_arg" attribute as a first argument and result of the Ajax call as a second argument. Optional.
 *  *after_arg*: Value for the JS function argument provided in "after" attribute. This could be an ID of an element, string, or any other arbitrary parameter. Any object will be converted to string. Optional.
 *  *confirm*:  Presents a !JavaScript confirmation dialog before making an Ajax call. The dialog will present the text with content from the attribute value.  If No or Cancel was selected on the dialog, the Ajax call is not made. Optional.
 *  *error*: Name of a JS function which will be called in case there was an Ajax error of some sort. The first parameter is HTTP status code, the second is response text sent from server.
 
 
==Example 1: Non-Ajax link==
{{{
 <@link_to controller="books" action="fetch">Get Books</@>
}}}
 
This will generate a simple non-Ajax link, such as: "..books/fetch"
 
*Example 2: Ajax link, sets data to destination element*
{{{
<@link_to controller="books" action="fetch" destination="result" >Get Books</@>
}}}

This will generate a simple Ajax link. The method by default is GET. After Ajax call, the result will be inserted into an element with ID: "result", similar to: `<div id="result"></div>`


==Example 3: Confirmation and before/after callbacks==
{{{
<@link_to controller="books"  id="123"
         method="delete" before="beforeDelete" after="afterDelete"
         confirm="Are you really sure you want to delete this book?">Delete Book</@>


   function beforeDelete(beforeArg){
      ...
   }

   function afterDelete(afterArg, data){
      ...
   }
}}}

Here, the JS confirmation dialog will present the message before posting an Ajax call, then function "beforeDelete" will be called. After that, it will make an Ajax call, and will execute function "afterDelete", passing it the result of Ajax invocation as an argument. In the JS code above, the "beforeArg" and "afterArg" arguments have values null since the "before_arg" and "after_arg" attributes were not used.

==Example 4: Before/after callback arguments==
{{{
<@link_to controller="books" action="fetch" before="doBeforeWithArg" before_arg="books_result"                               
    after="doAfterWithArg" after_arg="books_result">Get Books</@>
}}}

This code expects to find JS functions similar to these:
{{{
function doBeforeWithArg(elm){
  $("#" + elm).html("wait...");
}
 
function doAfterWithArg(elm, data){
  $("#" + elm).html(data);
}
}}}

This is presuming that there is an element like this on the page:
{{{
<div id="books_result"></div>
}}}
In this example, the "books_result" string is passed as argument to "doBeforeWithArg" as only one argument and the same is passed as a first argument to function "doAfterWithArg". The second argument to the "doAfterWithArg" is a result of Ajax invocation (presumably HTML representing books generated from some partial).

*Example 5 - Error handling*
{{{
<@link_to controller="books" action="doesnotexist" error="onError" destination="callbacks_result">Will cause error</@>

...
function onError(status, responseText){
  alert("Got error, status: " + status + ", Response: " + responseText);
 }
 }}}
 
 In this example, the link is making an Ajax call to a controlled action which does not exists. This causes onError() function to be triggered.

To be completed:

  * default layouts
  * custom layouts
  * layouts
  * ActiveWeb objects in context
  * FreeMarker?
  * Tags
  * FlashTag
  * confirmation
  * form
  * content_for, yield
  * Custom tag development 