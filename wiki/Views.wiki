#summary all about views for ActiveWeb developer

<wiki:toc max_depth="3" />

= Introduction =

Views in !ActiveWeb are also called templates. They are located in the following directory:
{{{
 ..src/main/webapp/WEB-INF/views
}}}

=No JSPs=

!ActiveWeb does not use JSPs. The main reason for not using JSPs is inability to test generated HTML with JSPs in a unit test. While the first implementation of !ActiveWeb used JSPs as the rendering engine, as soon as we started implementing the [Testing] framework, we quickly realized that this is simply impossible with JSPs. Generating HTML from a JUnit test is complex and impractical and would also be time consuming. Besides, the number of problems with different versions of JSP and JSTL specifications would be a nightmare to maintain. Thus we made a hard choice early on in 2010 to not use JSPs all together. In the long run this has proven to be a good decision, since it is possible to write very thorough tests with !ActiveWeb.

=!ActiveWeb uses !FreeMarker=
!ActiveWeb uses !FreeMarker as a templating engine. Please see [FAQ#Why_FreeMarker_? Why FreeMarker?] for more information. 

!ActiveWeb has a pluggable architecture that allows to integrate any other engine, such as Velocity, as long as they can implement [http://code.google.com/p/activeweb/source/browse/trunk/activeweb/src/main/java/activeweb/TemplateManager.java TempalteManager] interface. 

=!FreeMarker configuration=


TODO: complete this




=Templates=
!ActiveWeb templates are in fact !FreeMarker templates. However, there are a number of !ActiveWeb conventions for template naming and placement. Templates are located in sub-directories of this top view directory:
{{{ 
src/main/webapp/WEB-INF/views
}}}

The sub-directories are usually named after controllers. Controller name would loose suffix "Controller", and the remainder would be transformed from !CamelCase to underscore, for example, `HomeController` templates are located in sub-directory 
{{{
src/main/webapp/WEB-INF/views/home
}}}
and `OuterSpaceController` templates are located in:
{{{
src/main/webapp/WEB-INF/views/outer_space
}}}

Controller package is not considered in search of templates. Usually templates belong to a controller, but there can also be template that are shared. In that case, you can create any arbitrary directory under template top directory and place your shared templates there:
{{{
src/main/webapp/WEB-INF/views/shared
}}}


=Partials=

Partials are snippets of HTML pages, hence the word. Usually they host chunks of code repeating in a few places. In much the same way that a regular programming language allows develpers to refactor and keep repeating patterns of code in one place, partials a used to keep HTML code that is repeated. It is not to say though that you cannot put any arbitrary HTML code, you can.

The main power of partials is in their ability to iterate HTML snippets over data collections, as well as ability to "widgetize" HTML snippets.

Partials are somewhat similar to JSP includes, but they have some special characteristics that JSPs do not.

==Partials naming and location==
Partials are !FreeMarker templates as any other, but the name of file must start with underscore:

{{{
src/main/webapp/WEB-INF/views/greeting/_hello.ftl
}}}

Location of partials is the same as for regular templates, that is they are located in sub-directories of the top view directory.

==Include partials with Render tag==
Partials are included into a host page with a Render tag. Lets say there is a template called `index.ftl` located in directory `market` and partial `_fruit.ftl` located in the same diretory:
{{{
src/main/webapp/WEB-INF/views/market/index.ftl
src/main/webapp/WEB-INF/views/market/_fruit.ftl
}}}

then you can render `_fruit.ftl` inside `index.ftl` like this:
{{{
<html>
...
<@render partial="fruit"/>
...
</html>
}}}

As you can see, when you are referring to a partial, you _specify name without underscore_.
----
The Render tag requires at least one attribute present: "partial" which refers to a local or shared partial by name.
----

==Rendering shared partials==
In a previous example, you can see that a partial was co-located with the host template. Sometimes you need to render a partial in a number of templates. To accomplish this, you can place a partial into a new view directory and refer to a partial with "absolute" path, such as:
{{{
<html>
...
<@render partial="/shared/fruit"/>
...
</html>
}}}
This assumes that you have a partial fruit at this location:
{{{
src/main/webapp/WEB-INF/views/shared/_fruit.ftl
}}}
Use this technique to include a common widget across multiple templates. 

==Iterating with partials==
It is quite common to iterate over collections in a web application. Sometimes  you need to build a `<table>`, a list `<ul>` or repeating pattern of HTML code. Usually developers resort to loops inside templates, and although !FreeMarker provides this functionality, using partials provides a cleaner solution, as partials can iterate automatically.

Lets say we have a partial called `_fruit.ftl`:
{{{
Fruit name: ${fruit}<hr>
}}}
If we have a collection in context (java.util.List, for instance) with these values: ["apple", "prune", "pear"], and named fruits, then we can render this partial as a collection from host page like this:

{{{
<@render partial="fruit" collection=fruits/>
}}}
Rendering will result in this output:
{{{
Fruit name: apple<hr>Fruit name: prune<hr>Fruit name: pear<hr>
}}}
As you can see, iteration is easier with partials compared to loops. The partial will take care ot iterating automatically.

==Implicit counter in partial==
Partials interating over a collection have a built-in implicit variable maintaining an index of a collection. The name of this variable is made up of a name of a partial and word "counter". This means that for the above example, the name will be "fruit_counter". You can use this value inside a partial like any other context value. The above example with the counter modification:
{{{
Fruit name: ${fruit}, index: ${fruit_counter}<hr>
}}}
will yield:
{{{
Fruit name: apple, index: 0<hr>Fruit name: prune, index: 1<hr>Fruit name: pear, index: 2<hr>
}}}

==Partials with collections and spacers==
Notice in above examples  that the horizontal line `<hr>` is rendered at the bottom of each iteration of a partial. This is because it is really a part of a partial. It is quite common that you need to space the iterating snippets of HTML with some sort of a spacer made up of arbitrary HTML. Partials provide this capability with the use of a "spacer" partial. Lets say we use this partial as a spacer (located in `src/main/webapp/WEB-INF/views/shared/_divider.ftl`):
{{{
<div class='spacer'/>

}}} 
if we then render our fruits with this spacer such that"
{{{
<@render partial="fruit" collection=fruits spacer="divider"/>
}}}
we will get the following output:
{{{
Fruit name: apple<hr><div class="spacer"/>
Fruit name: prune<hr><div class="spacer"/>
Fruit name: pear<hr>
}}}
As you can see, the content of the spacer was inserted between the contents of the iterating partial, and the good thing is that it was not appended after the last iteration.
The reason for a new line is because we have it in a "divider" partial.


==Passing arguments to partials==
You can pass an argument value to a partial in much the same way as you can to a method. 

Lets say we have a host template:
{{{
<@render partial="fruit_name" a_fruit=fruit_name/>
}}}
and a partial (`_fruit_name.ftl`) with content:
{{{
Fruit name is: ${a_fruit}
}}} 
Then the output of a partial will be:
{{{
Fruit name is: apple
}}}
considering that there is a variable `fruit_name` in context. This variable could be passed in by controller, or created inside the template. The types of values passed in like this are not limited to strings.


==Boundary indicators for collection partials==
If you have a partial that iterates over a collection and you need to render special content conditionally if this is a first or last time in the iteration, you can use special variables set by the framework called `first` and `last`:

{{{
<#if first>
I'm the first in line!
</#>
<#if last>
I'm the last in line!
</#>

more content...
}}}



LinkTo tag and unobtrusive !JavaScript



=link_to tag and unobtrusibe !JavaScript=

!ActiveWeb provides a<@link_to/>. This tag generates an HTML anchor tag and is capable of regular HTML links, as well as Ajax capability.
 
==Attributes for configuration==

  * `controller` : path to controller, such as: `/admin/permissions` where "admin" is a sub-package and "permissions" is a name of a controller. In this example, the controller class name would be: `app.controllers.admin.PermissionsController`. If a controller path is specified, the preceding slash is mandatory. Optionally this could be a name of a controller from a default package: "permissions", and in this case, the controller class name is expected to be `app.controllers.PermissionsController`. If a name of controller is specified, the preceding slash can be omitted. This attribute is optional. If this attribute is omitted, the tag will use the controller which was used to generate the current page. This makes it convenient to write links on pages for the same controller.
  * `action` : name of a controller action, not HTML form action. Optional. If this attribute is omitted, the action will default to "index".
  * `id`: id, as in a route: /controller/action/id. Optional.
  * `html_id` : value of this attribute will be used to set the HTML ID of the Anchor element. Optional.
  * `query_string`: query string as is usually used in GET HTTP calls - the part of a URL after the question mark. Optional. Either query_string or query_params allowed, but not both.
  * `query_params` : java.util.Map with key/value pairs to be converted to query string. Optional. Either query_string or query_params allowed, but not both.
  * destination : id of an element on page whose content will be set with a result of an Ajax call. Optional.
  * `form` : id of a form element on the page, whose content will be serialized into the Ajax call. This content will be submitted to the server controller/action as input. Optional.
  * `method` : HTTP method to use. Acceptable values: GET (default), POST, PUT, DELETE. Optional.
  * `before` : Name of a !JavaScript function to call before making Ajax call. Optional. This function does not receive any arguments.
  * `before_arg` : Value for the JS function argument provided in "before" attribute. This could be an ID of an element, string, or any other arbitrary parameter. Any object will be converted to string. Optional.
  * `after` : Name of a !JavaScript function to call after making Ajax call. This function receives the value of a "after_arg" attribute as a first argument and result of the Ajax call as a second argument. Optional.
  * `after_arg` : Value for the JS function argument provided in "after" attribute. This could be an ID of an element, string, or any other arbitrary parameter. Any object will be converted to string. Optional.
  * `confirm` :  Presents a !JavaScript confirmation dialog before making an Ajax call. The dialog will present the text with content from the attribute value.  If No or Cancel was selected on the dialog, the Ajax call is not made. Optional.
  * `error` : Name of a JS function which will be called in case there was an Ajax error of some sort. The first parameter is HTTP status code, the second is response text sent from server.
 
 
==Example 1: Non-Ajax link==
{{{
 <@link_to controller="books" action="fetch">Get Books</@>
}}}
 
This will generate a simple non-Ajax link, such as: "..books/fetch"
 
==Example 2: Ajax link, sets data to destination element==
{{{
<@link_to controller="books" action="fetch" destination="result" >Get Books</@>
}}}

This will generate a simple Ajax link. The method by default is GET. After Ajax call, the result will be inserted into an element with ID: "result", similar to: `<div id="result"></div>`


==Example 3: Confirmation and before/after callbacks==
{{{
<@link_to controller="books"  id="123"
         method="delete" before="beforeDelete" after="afterDelete"
         confirm="Are you really sure you want to delete this book?">Delete Book</@>


   function beforeDelete(beforeArg){
      ...
   }

   function afterDelete(afterArg, data){
      ...
   }
}}}

Here, the JS confirmation dialog will present the message before posting an Ajax call, then function "beforeDelete" will be called. After that, it will make an Ajax call, and will execute function "afterDelete", passing it the result of Ajax invocation as an argument. In the JS code above, the "beforeArg" and "afterArg" arguments have values null since the "before_arg" and "after_arg" attributes were not used.

==Example 4: Before/after callback arguments==
{{{
<@link_to controller="books" action="fetch" before="doBeforeWithArg" before_arg="books_result"                               
    after="doAfterWithArg" after_arg="books_result">Get Books</@>
}}}

This code expects to find JS functions similar to these:
{{{
function doBeforeWithArg(elm){
  $("#" + elm).html("wait...");
}
 
function doAfterWithArg(elm, data){
  $("#" + elm).html(data);
}
}}}

This is presuming that there is an element like this on the page:
{{{
<div id="books_result"></div>
}}}
In this example, the "books_result" string is passed as argument to "doBeforeWithArg" as only one argument and the same is passed as a first argument to function "doAfterWithArg". The second argument to the "doAfterWithArg" is a result of Ajax invocation (presumably HTML representing books generated from some partial).

==Example 5 - Error handling==
{{{
<@link_to controller="books" action="doesnotexist" error="onError" destination="callbacks_result">Will cause error</@>

...
function onError(status, responseText){
  alert("Got error, status: " + status + ", Response: " + responseText);
 }
 }}}
 
 In this example, the link is making an Ajax call to a controlled action which does not exists. This causes onError() function to be triggered.





=form tag=

`<@form/>` tag generates an HTML form tag and has functionality specific for !ActiveWeb.
Like any other !ActiveWeb tag, it has ability to pass through any non - !ActiveWeb attributes. This means that if you
specify any attribute that is not mentioned here, it will be passed through as a regular HTML attribute.


Attributes:

  * `controller` - name of a controller to post this form to. Optional. If this attribute is not provided, the tag will find a current controller in context which was used to generate a data for the current view and uses it.  It makes it convenient to write many views for the same controller.
  * `action` - name of an action to post this form to.This is different from  regular HTML form@action attribute, as controller, action and id attributes will be used to form an appropriate HTML form action value.  Optional. 
  * `id` - value of URI "id". Used as URI "id" in forming an HTML Form action attribute, such as: `<form action="controller/action/id"`. Do not confuse with HTML element ID. Optional.
  * `html_id` - value of HTML Form element ID, as in `<form id="123..."`. Optoinal.
  * `method` - this is an HTTP method. Allowed values: GET (default), POST, PUT, DELETE.

In case the values are "put" or "delete", additional hidden input names `_method` will be generated, and the actual HTML method will be set to "post". This workaround is necessary because browsers still do not support PUT and DELETE. Optional. 


Examples (given that the current context is "simple_context"):
==Simple form==
code:
{{{
<@form controller="simple" action="index" method="get"/>
}}}
will generate this HMTL:
{{{
<form action="/simple_context/simple/index" method="get"/>
}}}

==POST form with ID==
code:
{{{
<@form controller="simple" action="index" id="123" method="post" html_id="formA"/>
}}}
will generate:
{{{
<form action="/simple_context/simple/index/123" method="post" id="formA"/>
}}}

==PUT form==
code:
{{{
 <@form controller="simple" action="index" method="put">
      <input type="hidden" name="blah">
 </@form>
}}}
will generate this HMTL:
{{{
<form action="/simple_context/simple/index" method="post">
      <input type='hidden' name='_method' value='put' />
      <input type="hidden" name="blah">
</form>
}}}

==PUT form for RESTful controller==

This tag also is REST-aware, and will generate appropriate formats for HTML Form tag action value depending if the controller is RESTful or not.

code:
{{{
<@form controller="photos"  id="x123" method="put" html_id="formA">
      <input type="hidden" name="blah">
</@form>
}}}
will generate:
{{{
 <form action="/simple_context/photos/x123" method="post" id="formA">
      <input type='hidden' name='_method' value='put' />
      <input type="hidden" name="blah">
 </form>
 }}}
 
=debug tag=
Debug tag is for printing an arbitrary object from page context. !FreeMarker special handling of types sometimes makes it hard to see the value(s) of an object when debugging, but this tag makes it easy:
{{{
<@debug print=objectname/>;
}}}

For instance, for a `java,util.Map` object it will print this:
{{{
     {key1=value1, key2=value2}
}}}


=!ActiveWeb layouts=
Layouts are a way to decorate a page with additional HMTL. !ActiveWeb layouts serve exactly the same purpose as Java technologies such as Apache Tiles and Sitemesh.
Using a layout you decorate every page with the same header,footer, and other common elements for your application.
Layouts are !FreeMarker templates like any other.

==Default layout==
A default layout is called default_layout.ftl and located in the layouts directory along with other tempalte directories:

{{{
src/main/webapp/WEB-INF/views/layouts/default_layout.ftl
}}}

The content of the default_layout from a startup project looks like this (few lines omitted for clarity):

{{{
1.  <html>
2.  <head>
3.      <title>ActiveWeb - <@yield to="title"/></title>
4.  </head>
5.  <body>
6.  <div class="main">
7.  <#include "header.ftl" >
8.      <div class="content">
9.      ${page_content}
10.     </div>
11. <#include "footer.ftl" >
12. </div>
13. </body>
14. </html>
}}}


Line 3 has a `yield` tag, for explanation, please see section below. 
Line 7 includes a header.ftl, which is another template with code for the top portion of your site. It is not strictly necessary, since you can copy all code
from header directly into layout, but it is a good practice to keep it in a separate file. 
Line 11 serves the same purpose for footer, as line 7 for header.

Line 9 is where entire page generated from rendering a controller response is inserted. 

==`content for` and `yield` tags ==

When using layout, you quite often need to pass information from a rendered page up to a layout. Examples are: page title. as in the example of a layout above,
on line 3, there is a `title` tag, but the information for title of a page is of course in the page itself. The tags `content for` abd `yield` work together 
to allow to pass information from page up to a layout.

===Simple `content for`  and `yield` case===
Here is an example of passing a  page title from a page template to layout:
{{{
<@content for="title">Books List</@content>
}}}

When the entire page with layout is rendered, the  line 3 will read like this:
{{{
<title>ActiveWeb - Books List</title>
}}}

Think of `content for` as setting some content for a location in layout, and `yield` as yielding to that content. 

content for and yeld are not limited to sending plain text, you can send arbitrary HTML chunks, including `<script>` tags, CSS, links to various resources, etc.

This feature is useful to inject a JavaScript library into a layout from a page in cases you only need this library on this one page. This way loading a library will be avoided for all other pages, where it is not used. 

===Multiple chunks of `content for`  for single `yield`===

Sometimes you need to send multiple chunks of text from a page to layout. You can declare more than one `content for` with the same yield target:

{{{
<@content for="js">
<script type="text/javascript">
    Window.alert("hello1");
</script>
</@>

<@content for="js">
<script type="text/javascript">
    Window.alert("hello2");
</script>
</@>
... declare more if needed
}}}


The yield tag in layout looking like this:
{{{
<@yield to="js"/>
}}}
will generate the following output in its place:
{{{
<script type="text/javascript">
    Window.alert("hello1");
</script>
<script type="text/javascript">
    Window.alert("hello2");
</script>
}}}

==Rendering without layout==

==Override default layout==


To be completed:
{{{
  * default layouts
  * custom layouts
  * layouts
  * ActiveWeb objects in context
  * FreeMarker?
  * Tags
  * FlashTag
  * confirmation
  * form
  * content_for, yield
  * Custom tag development 
}}}